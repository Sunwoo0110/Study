# 📚 Scale out

---

## 1. 주제/키워드
- 시스템을 확장할 때 고려해야 할 설계 요소에 대해 알아보자~ ♪( ´θ｀)ノ

---

## 2. 핵심 요약 (Summary)

### 단일 서버
- 단일 서버(웹, 앱 DB, 캐시 등이 하나의 서버에)에서 작동한다고 생각해보자~
- 요청 흐름
  - DNS(Domain Name Service)를 통해 도메인 -> IP 주소 변환
  - 해당 IP 주소로 HTTP 요청 전달
  - 요청 받은 웹 서버는 HTTP 페이지나 Json 형태의 응답 반환

---

### 데이터베이스 서버
- 이제 데이터베이스 서버를 분리해서 독립적으로 확장해보자~
- 관계형 데이터베이스(RDBMS)
  - row, column으로 표현
  - SQL을 사용하여 여러 테이블의 데이터를 join해서 합칠 수 있음
  - MySQL, Oracle, PostgreSQL
- 비관계형 데이터베이스(NoSQL)
  - 일반적으로 join 지원하지 않음
  - key-value store(Redis), graph store, column store, document store(MongoDB)
  - 언제 사용할까?
  - 아주 **낮은 응답 지연시간**(latency)이 요구될 때
  - 데이터가 **비정형**(unstructured) (관계형이 아님)
  - 데이터를 직렬화, 역직렬화 할 수 있기만 하면 됨
  - **아주 많은 데이터**를 저장해야 함

---

### Scale out (수평적 규모 확장)
- Scale up (수직적 규모 확장)
  - 서버에 고사양 리소스를 추가하는 방법
  - 한계가 존재(1개의 서버에 추가할 수 있는 CPU, 메모리는 제한)
  - 장애 발생 시 자동 복구(failure), 다중화(redundancy) 가 없음 -> 서버 1대에 장애 발생 시 완전히 중단(SPOF)
- Scale out (수평적 규모 확장)
  - 더 많은 **서버를 추가해 성능 개선**하는 방법

---

### Load balancer (로드밸런서)
- load balancing set (부하 분산 집합)에 속한 **웹 서버들에게 트래픽을 고르게 분산**
- 요청 흐름
  - 사용자는 로드밸런서의 public IP 주소로 접속
  - 로드밸런서는 private IP 주소로 웹 서버에 접속
- **장애 복구**
  - 서버 1이 다운되면, 모든 트래픽은 서버 2로 전송 -> 전체 다운 방지
  - 만약 트래픽이 증가해서 서버를 추가하면, 로드밸런서가 자동적으로 트래픽 분산

---

### Database Redundancy (데이터베이스 다중화)
- Master(주 서버) 와 Slave(부 서버)로 나누어, 원본은 주 서버에 사본은 부 서버에 저장
- **Write 연산(insert, delete, update 등)은 주 서버에만 지원**
- 부 서버는 주 서버에서 사본을 받아, read 연산만 지원
- 대부분은 read가 write보다 훨씬 많음 -> 주 서버 수 < 부 서버 수
- 장점
  - **성능 개선**: read 연산을 부 서버들에서 **병렬로 처리** 가능
  - **안정성**(reliability): DB 서버들 일부에 문제가 생겨도 데이터 보존
  - **가용성**(availability): 하나의 DB 서버에 장애가 생겨도 다른 서버의 데이터를 가져와 계속 서비스
- 장애 복구
  - 부 서버가 1개인데 다운됨
    - 일시적으로 read 연산이 모두 주 서버에 전달
    - 즉시 새로운 부 서버가 장애 서버 대체
  - 부 서버가 여러 개인데 다운됨
    - read 연산이 나머지 서버에 분산
  - 주 서버 다운
    - 부 서버가 새로운 주 서버 -> write 연산 수행
    - 새로운 부 서버 추가
    - 만약, 부 서버에 보관되있던 데이터가 최신이 아닌 경우 복구 스크립트로 최신 데이터 추가
      - multi-master(다중 마스터), circular replication(원형 다중화)
- 요청 흐름
  - DNS로부터 **로드밸런서의 public IP 주소**를 받음
  - 해당 IP 주소로 로드밸런서에 접속
  - 사용자의 HTTP 요청이 로드밸런서에 의해 정해진 서버로 전달
  - 웹 서버는 데이터를 **부 서버에서 읽음**
  - **데이터 변경 연산은 주 서버**에서 실행
- 여기서 잠깐!!
- Multi-master(다중 마스터) 이란?
  - **여러 개의 DB 서버(마스터)가 모두 읽기/쓰기 가능**한 구조
  - 모든 노드가 클라이언트의 요청(특히 write)을 직접 처리 가능
  - 한 노드에서 변경된 데이터는 나머지 노드에도 복제(replication)되어 동일한 데이터셋 유지
  - 장점
    - **가용성 향상**: 1개의 주 서버가 다운돼도 다른 주 서버가 계속 서비스 가능
    - **응답 속도 개선**: 지리적으로 분산된 주 서버에에 접근 가능
  - 단점
    - **일관성(Consistency)**: 대부분은 비동기 혹은 lazy 동기 -> ACID 위배 가능
    - **성능 부담**: eager replication 시 통신 지연 증가, 구현 복잡
    - **데이터 무결성 문제**: 노드 수 증가 및 지연 증가 시 충돌 해결이 어려워짐

- Circular replication(원형 다중화) 이란?
  - 여러 DB 인스턴스(또는 클러스터)가 순환 구조로 서로 복제하는 방식
  - Cluster1 -> Cluster2 -> Cluster3 -> Cluster1
  - 각 노드가 다른 노드의 **소스**(Source)이자 **복제**(Replica)가 됨
  - 장점
    - **가용성 향상**: 특정 노드 장애 시 다른 경로를 통해 데이터 복구 가능
    - **분산 부하**: 쓰기 요청을 여러 노드에 분산 가능
    - **지리적 분산 용이**: 여러 지역에 배치된 노드를 연결 가능
  - 단점
    - **충돌 가능성**: 여러 노드에서 동일한 데이터 동시 변경 시 Conflict 발생 -> Conflict Resolution 필요
    - **지연 전파**: 순차 전파 특성상 마지막 노드까지 변경이 도달하는 데 시간이 걸림
    - **복잡성 증가**: 노드 수가 많아질수록 장애 시 복구 절차 복잡

---

### Cache
- 비싼 연산 결과나 자주 참조되는 데이터를 메모리 안에 두고, 다음 요청이 빨리 처리될 수 있도록 하는 저장소
- 장점
  - 성능 개선: 데이터베이스보다 훨씬 빠름, DB 부하 감소
  - 캐시 계층 독립적으로 확장 가능
- 더 자세한 내용은~~ [backend_cache.md](Study/Backend/backend_cache.md)

---

## CDN (콘텐츠 전송 네트워크)
- **정적 콘텐츠 전송**에 사용되는, **지리적으로 분산**된 서버의 네트워크
- 이미지, 비디오, CSS, Javascript 파일 등을 캐시
- 동적 콘텐츠 캐싱: request path, query string, cookie, request header 등의 정보에 기반하여 HTML 페이지를 캐시하는 것
-  사용자가 웹사이트에 방문하면, 가장 가까운 CDN 서버가 정적 콘텐츠를 전달
- 가까울수록 빠르고, 멀수록 느리게 로딩
- 요청 흐름
  - 사용자가 URL를 이용해 image.png에 접근
  - 이때, URL의 도메인은 CDN 서비스 사업자가 제공
  - CDN 서버 캐시에 해당 이미지가 없는 경우, 원본 서버에 요청하여 파일 가져옴
  - 원본 서버가 파일을 CDN 서버에 반환함. 이 때, HTTP 헤더의 TTL으로 해당 파일이 얼마나 오래 캐시될 수 있는 지 명시
  - CDN 서버는 파일을 캐시하고, 사용자에게 반환
- 고려 사항
  - 비용: 보통 제3 사업자에 의해 운영되기 때문에 요금 부과
  - 만료 기간: 너무 길면 콘텐츠의 신선도가 떨어지고, 짧으면 원본 서버에 자주 접속
  - 장애: CDN이 죽었을 때, 문제 감지해서 원본 서버에서 직접 가져오도록
  - 콘텐츠 무효화(invalidation): CDN에서 제거

---

### Stateless 
- 웹 계층을 수평적으로 확장하기 위해서는, **상태 정보**(사용자 세션 데이터 등)를 제거해야함
- 상태 정보를 지속적 저장소에 저장하고, 필요할 때 가져오는 방식 -> stateless
- 상태 정보 의존적 아키텍처
  - 상태(client 정보)를 유지하여 요청들 사이에 공유
  - 각 서버는 서로 다른 사용자 정보를 가지고 있음
  - 따라서 **같은 클라이언트 요청은 항상 같은 서버로 전송**해야함 -> 로드밸런서 부담
- 무상태 아키텍처
  - 상태 정보를 공유 저장소에 저장하여 필요할 때 가져옴
  - 웹 서버로부터 물리적으로 분리 -> 단순, 안정적, 규모 확장 편리
  - 이로 인해 웹 서버 계층은 **autoscaling**(자동 규모 확장)이 가능!

---

### 데이터 센터
- 가장 가까운 데이터 센터로 접속 -> 지리적 라우팅(geoDNS-routing)
- geoDNS: 사용자 위치에 따라 도메인을 어떤 IP 주소로 변환할 지 결정하는 DNS
- 만약 특정 데이터 센터에 장애가 발생하면, 모든 트래픽은 장애가 없는 데이터센터에 전달
- 기술적 포인트
  - **트래픽 우회**: 가장 가까운 데이터센터로 트래픽 전송
  - **데이터 동기화**
    - 각 데이터센터 속 개별 DB를 사용하는 경우, 장애가 자동으로 복구(failover)되어 트래픽이 다른 DB로 우회하면, 원하는 데이터가 없는 경우가 발생
    - 데이터를 여러 데이터센터로 **다중화**하여 방지
  - **테스트와 배포**: 여러 위치에서 테스트, 자동화된 배포 도구로 모든 데이터 센터에 동일한 서비스가 설치되도록
- 넷플릭스의 Active-Active for Multi-Regional Resiliency
  - 원칙
    - 서비스는 **stateless**, 모든 데이터/상태 복제는 데이터 계층에서 처리해야 함
    - **모든 리소스(S3, SQS 등)는 로컬 리전**에서만 접근 가능
    - 사용자 요청 경로에 크로스 리전 호출이 없어야 함
    - **데이터 복제는 비동기 방식**
  - 기술
    - **정확한 리전으로 트래픽 라우팅**
      - DNS 사용(UltraDNS + Route53)
    - **트래픽 shaping 및 부하 차단**(thundering herd 문제 방지)
      - Traffic Shaping: 트래픽을 제어하고 분배하는 기술 -> 시스템이 안정적으로 동작
      - Thundering Herd 문제: 한꺼번에 매우 많은 요청이나 작업이 동시에 몰려서 서버나 DB, 캐시가 과부하되는 현상
      - Zuul: Netflix의 모든 Edge 서비스 앞단에 위치한 게이트웨이 레이어
      - 잘못 라우팅된 요청 식별 및 처리
      - Failover 모드 선언 시 **모든 요청을 로컬에서 처리**
      - 최대 트래픽 제한 설정 -> 초과 시 요청 차단으로 다운스트림 서비스 보호
    - **비동기 데이터 복제**
      - Cassandra + EvCache
      - 다중 마스터 캐시 복제 대신 **원격 캐시 무효화 방식** 사용
      - 한 리전에서 **write 발생** 시 SQS로 **다른 리전 캐시 무효화** -> Cassandra 재조회 후 **로컬 캐시 갱신**
    - 멀티 리전 배포 자동화
      - 카나리 배포 및 자동 롤백

---

### Message Queue (메세지 큐)
- **메세지 무손실**(durability)를 보장하는 **비동기 통신**을 지원하는 컴포넌트
- 메세지 무손실: 메세지 큐에 보관된 메세지는 소비자가 꺼낼 때까지 안전하게 보관
- 메세지의 버퍼 역할, 비동기적으로 전송
- producer가 메세지 생산하고 메세지 큐에 발행 -> consumer가 메세지를 받아 수행
- 장점
  - 서비스/서버 간의 결합이 느슨해져서 **규모 확장에 용이**
  - 생산자, 소비자 서비스 규모 독립적으로 확장
  - **병렬 처리** 가능
  - 큐에서 요청 일시적으로 저장하여 **버퍼 역할** -> **부하 감소**

---

### 로그, 매트릭, 자동화
- 로그
  - 에러 로그 모니터링을 통해 오류와 문제 빠르고 쉽게 확인
- 메트릭
  - 사업 현황, 시스템 상태 등에 유용한 정보 확인 가능
- 자동화
  - 시스템이 크고 복잡할 때 생산성이 높아짐
  - CI(Continous Integration, 지속적 통합) 도구를 사용하면 코드가 검증 절차를 자동으로 거치게할 수 있음

---

### 데이터베이스 규모 확장
- 수직적 확장(Scale Up)
  - 더 많은, 더 좋은 리소스 사용(CPU, RAM, 디스크 등)
  - 무한한 증설이 어려움
  - SPOF으로 인한 위험성이 큼
  - 비용이 많이 듦
- 수평적 확장
  - **Sharding**
    - 더 많은 DB 서버를 추가하여 성능 향상
    - Shard 라고 불리는 작은 단위로 분할하는 기술
    - 모든 샤드는 **같은 스키마를 사용**
    - 샤드에 보관되는 데이터 사이에 **중복 없음**
  - 주의점
    - **샤딩키**를 어떻게 정할 것인가..
    - 샤딩키: 데이터가 어떻게 분산될 지 정하는 하나 이상의 칼럼
    - **데이터를 고르게 분산**할 수 있도록 설정
  - 발생하는 문제
    - Resharding(재샤딩)
      - 데이터가 너무 많아져서 **하나의 샤드로 감당하기 어려울 때**
      - 샤드 간 **데이터 분포가 균등하지 않아** 특정 샤드의 공간 소모가 빨리 진행될 때(**shard exhaustion**, 샤드 소진)
      - 해결 방법: 샤드키 계산 함수 변경, 데이터 재배치
    - Celebrity problem(유명인 문제) / Hotspot Key
      - **특정 샤드에 쿼리가 집중**되어 서버에 과부하
      - 해결 방법: Hot key를 각 샤드에 할당 혹은 더 잘게 쪼개기
    - Join + Denormalization (조인 + 비정규화)
      - 하나의 DB를 여러 샤드로 쪼개면, 여러 샤드의 데이터를 조인하기 어려움
      - 해결 방법: DB 비정규화하여 하나의 테이블에서 쿼리 수행 가능하도록

---

### 시스템 규모 확장을 위한 기법
- 웹 계층 stateless
- 모든 계층에 다중화 도입
- 가능한 많은 데이터 캐시
- 여러 데이터 센터 지원
- 정적 콘텐츠는 CDN 사용
- 데이터 계층은 샤딩을 통해 규모 확장
- 각 계층 독립적으로 분할
- 지속적으로 모니터링, 자동화 도구 사용

---

## 3. 참고/추가 자료 (References)
- 가상 면접 사례로 배우는 대규모 시스템 설계 기초

---

## 4. 내일/다음에 볼 것 (Next Steps)
- 무중단 배포 공부하자~
