# 📚 Index

---

## 1. 주제/키워드
- 데이터베이스의 인덱스에 대해 알아보자~ ✧*｡٩(ˊᗜˋ*)و✧*｡ 

---

## 2. 핵심 요약 (Summary)
### 랜덤 I/O와 순차 I/O
- 순차 I/O는 요청을 한번에 처리하기 때문에, 랜덤 I/O보다 성능이 뛰어남
- 쿼리 튜닝: 랜덤 I/O를 줄이는 것 -> 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것

### Index
- 칼럼(혹은 칼럼들)의 값과 해당 레코드가 저장된 주소를 key-value 쌍으로 저장하는 것
- 주어진 순서로 미리 정렬해서 보관
- DBMS의 인덱스는 **SortedList 자료구조**를 사용(저장되는 값이 항상 정렬된 상태로 유지)
- 저장하는 과정(Insert, Update, Delete)이 복잡하고 느리지만, 조회가 매우 빠름
- 따라서 **인덱스는 저장 성능을 희생하고, 데이터 읽기 속도를 높이는 기능**

---

### 인덱스 분류
#### 역할
- Primary Key
  - 레코드를 대표하는 칼럼의 값으로 만들어진 인덱스
  - Null 허용 금지, 중복 허용 금지
- Secondary Key(Index)
  - Primary Key를 제외한 나머지

#### 데이터 저장 방식(알고리즘)
- B- Tree 알고리즘
  - 가장 일반적인 알고리즘
  - 칼럼 값을 변형하지 않고, 원래의 값을 이용
- Hash 인덱스 알고리즘
  - 칼럼의 값을 해시값으로 계산
  - 매우 빠른 조회 성능
  - Prefix 일치, 일부 검색, 범위 검색에는 사용 불가능
  - 주로 메모리 기반 DB에서 많이 사용

#### 중복 허용 여부
- Unique Index vs Non-Unique Index

---

### B- Tree 인덱스
- 추가: 오래 걸리고 비용이 많이 듦
- 삭제: 리프 노드에 삭제 마크만 함 -> 간단함
- 변경: 삭제 후 키 추가
- 검색: 트리 탐색을 이용하여 빠른 조회
- 성능에 영향을 주는 요인
  - **인덱스 키 값 크기**
    - 키 값의 크기가 커지면 디스크로부터 읽어야하는 횟수가 늘어남 -> 느려짐
    - 인덱스 캐시 공간이 한정적이기 때문에, 인덱스 크기가 커지면 캐시 가능한 레코드 수가 줄어듦 -> 메모리 효율이 떨어짐
  - **B- Tree 깊이**
    - 인덱스 키 값이 커지면 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 적어짐 -> 같은 레코드 개수여도 B- Tree 깊이가 깊어져 디스크 읽기가 더 많이 필요
    - 인덱스 키 값의 크기는 가능한 작게 생성
  - **선택도**(기수성)(Cardinality)
    - 모든 인덱스 값 중 유니크한 값의 수(중복도가 얼마나 낮은지)
    - Cardinality 높음 -> 중복 적음
    - 중복 값이 많을수록 성능 저하
  - **읽어야하는 레코드 개수**
    - 인덱스를 통행 읽어야하는 레코드 개수가 전체 테이블 레코드의 20~25%를 넘어가면 인덱스를 이용하지 않고 테이블 전체를 읽어서 필요한 레코드만 필터링하는 방식이 효율적

---

### B- Tree 조회
#### Index Range Scan
- 조건절이 인덱스 앞부분과 일치하거나 범위를 지정한 경우 사용
- ex. `WHERE age BETWEEN 20 AND 29, WHERE name LIKE 'Kim%'`
- B-Tree를 통해 시작 위치를 찾고, 조건에 맞는 범위까지 순차적으로 탐색
- 가장 자주 사용

#### Index Full Scan
- 인덱스 전체를 처음부터 끝까지 읽는 방식
- ex. `ORDER BY indexed_column` (WHERE 조건이 없을 때)
- 테이블 풀스캔보다 유리할 때 사용
  - 인덱스 크기가 테이블보다 훨씬 작고
  - 필요한 컬럼이 인덱스만으로 충족 가능할 때

#### Loose Index Scan
- 인덱스의 특정 그룹만 읽어도 될 때 사용
- ex. `SELECT MIN(order_date), MAX(order_date) FROM orders GROUP BY customer_id;`
- 모든 인덱스 레코드를 보지 않고, 각 그룹의 첫 레코드만 추출
- 일반 Range Scan보다 훨씬 효율적

#### Index Skip Scan
- 복합 인덱스에서 선행 컬럼 조건이 없어도 후행 컬럼으로 탐색할 때 사용
- ex. 인덱스 (gender, age) 가 있을 때 원래는 WHERE age = 30 못 쓰는데 Optimizer가 gender 값별로 인덱스를 나눠 스킵하면서 후행 컬럼으로 조건 탐색 가능
- MySQL 8.0부터 지원
- Cardinality가 낮은 선행 컬럼일수록 효과적 (gender처럼 값 종류가 적을 때)

---

### Muti-Column Index
- 두 개 이상의 컬럼을 묶어서 만든 인덱스
- **컬럼 순서가 매우 중요**
- (col1, col2) 인덱스가 있을 때
  - WHERE col1 = ? -> 인덱스 사용 O
  - WHERE col2 = ? -> 인덱스 사용 X (Skip Scan으로 일부 가능)
  - WHERE col1 = ? AND col2 = ? -> 인덱스 사용 O

---

### B- Tree 인덱스의 정렬 및 스캔 방향
- 인덱스는 ASC(오름차순) 정렬 상태로 저장됨
- 하지만 MySQL 옵티마이저는 역순(Descending) 스캔도 가능
- **역순 스캔이 정속 스캔에 비해 느림**
- 따라서 역순 스캔이 자주 사용된다면, 내림차순 인덱스가 효율적
- 많은 쿼리가 인덱스 앞, 뒤만 집중적으로 읽어 병목이 예상된다면, 자주 사용되는 정렬 순서대로 인덱스 생성

---

### B- Tree 인덱스의 가용성과 효율성
- 범위 결정 조건은 많을수록 쿼리 처리 성능을 높임
- 체크 조건은 많다고 해서 처리 성능을 높이지 못함(더 느리게 만들수도 있음)
  - 체크 조건: 범위를 줄이지 못하고 단순 거름종이 역할만 하는 것
- 인덱스 사용할 수 없는 조건
  - NOT EQUAL 비교
  - 뒷부분 일치 `LIKE '%abc'`
  - 인덱스 칼럼이 변경된 후 비교
  - 데이터 타입 서로 다름
- 범위 조건은 많을수록 쿼리 처리 성능을 높임
- 필터링 조건은 많다고 해서 처리 성능을 높이지 못함(더 느리게 만들수도 있음)

---

### R- Tree
- 공간 데이터(Spatial Data) 저장을 위해 고안된 인덱스 구조
- 2차원(좌표), 3차원(지도 데이터) 검색에 적합

---

### 전문 검색(Full Text Search)
- 문서의 내용 전체를 인덱스화해서 특정 키워드가 포함된 문서 검색
- 일반 `LIKE '%keyword%'` 검색보다 훨씬 빠르고 효율적
- 불용어 처리: 가치가 없는 단어 필터링해서 제거

#### 어근 분석 알고리즘 (Stemming)
- 검색어 단어의 원형을 찾는 작업
- 같은 어근(root)을 가진 단어를 묶어 검색
- ex. run, running, ran -> 동일 단어로 처리
- 한국어는 어근 분석 보다는 형태소를 분석해서 명사와 조사를 구분하는게 더 중요

#### n-gram 알고리즘
- 키워드 검색을 위한 인덱싱 알고리즘
- 문자열을 n개의 연속된 문자 단위로 분리
- ex. database (2-gram) -> da, at, ta, ab, ba, as, se
- 한국어처럼 띄어쓰기 단위로 의미가 잘 안 나눠지는 언어에 주로 사용됨

#### 불용어(Stop word) 변경 및 삭제
- 오히려 불용어 처리가 사용자에게 혼란을 줄 수 있음
- 따라서 MySQL 내장 불용어 대신 사용자가 불용어를 직접 등록하는 방식 권장

#### Full Text 검색 인덱스의 가용성
- Full Text 검색 인덱스 사용 조건
  - 쿼리 문장이 full text 검색을 위한 문법을 사용
  - 테이블이 full text 검색 대상 칼럼에 대해 full text 인덱스 보유

--- 

### 함수 기반 인덱스
- 칼럼 값을 변형해서 인덱스를 구축할 경우 사용

#### 가상 칼럼을 이용한 인덱스
- 테이블에 계산된 컬럼을 추가하고, 거기에 인덱스 적용
  
#### 함수를 이용한 인덱스
- 특정 함수 결과에 직접 인덱스를 생성
- 테이블 구조를 변경하지 않음

---

### Muti Value 인덱스
- 하나의 데이터 레코드가 여러 개의 키 값을 가질 수 있음
- JSON 칼럼 인덱스 생성 가능

---

### 프라이머리 키가 세컨더리 인덱스에 미치는 영향
- InnoDB에서 세컨더리 인덱스는 항상 (세컨더리 키 + PK) 구조로 저장(정확히는 리프 노드에 저장)
- 조회 과정: 세컨더리 인덱스 B-Tree 탐색 -> 조건에 맞는 세컨더리 키 찾음 -> 리프 노드에서 PK 값을 얻음 -> PK 값으로 다시 클러스터링 인덱스 탐색 -> 행 전체 반환
- 따라서 PK가 길면 세컨더리 인덱스도 커지고 성능 저하
- PK 변경 시 세컨더리 인덱스 전부 수정 필요 -> PK는 짧고 불변한 값이 적합
- 세컨더리 인덱스는 PK 포함 덕분에 일부 쿼리에서 커버링 인덱스로 활용 가능
  - 커버링 인덱스: 쿼리에서 필요한 컬럼이 모두 인덱스 안에 포함되어 있어 테이블 데이터까지 안 가고 인덱스만으로 처리 가능한 경우

#### PK 말고 세컨더리 인덱스를 타는 경우
- PK가 아닌 컬럼으로 검색할 때
- PK가 아닌 컬럼으로 정렬/ORDER BY 할 때
- PK가 아닌 컬럼으로 JOIN 조건 걸릴 때
- 복합 인덱스에서 첫 컬럼이 PK가 아닐 때
- 커버링 인덱스가 가능한 경우

---

### Clustering Index
- 테이블의 데이터 자체가 **프라이머리 키(Primary Key) 순서대로 정렬되어 저장**되는 구조
- InnoDB에서는 항상 PK = 클러스터링 인덱스
- PK 기준으로 B-Tree 구조에 정렬 저장되고, 리프 노드에는 실제 레코드(행 전체, 모든 컬럼)가 저장
- 조회 순서: PK 값으로 B-Tree 탐색 -> 리프 노드 -> 바로 행 반환
- 장점
  - PK 검색이 매우 빠름 (데이터가 곧 인덱스이기 때문)
  - PK 기준으로 범위 검색(BETWEEN, ORDER BY) 효율적
  - 세컨더리 인덱스가 PK를 참조하므로 커버링 인덱스로 활용 가능
- 단점
  - PK 값이 클 경우, 세컨더리 인덱스 크기도 커짐 (모든 세컨더리 인덱스는 PK 포함)
  - PK 값 변경 시, 레코드 자체를 이동해야 하므로 비용 큼
  - Insert 시 PK 순서가 뒤죽박죽이면 페이지 분할(Page Split) 발생 -> 성능 저하
- 주의 사항
  - 인덱스(PK) 키 크기가 길수록 모든 세컨더리 인덱스도 커져서 비효율적
  - auto-increment보다 업무적으로 자주 쓰이는 컬럼을 PK로 설정하는 게 유리한 경우 많음
  - PK 명시하지 않으면 InnoDB가 내부적으로 자동 생성 (16바이트 hidden PK)
  - Auto-increment PK 사용 시 값이 항상 증가 -> 페이지 분할 거의 없음 -> Insert 성능 좋음
    - 하지만 의미 없는 숫자일 수 있어서 추가 인덱스 필요할 수 있음
- 페이지 분할(Page Split) 이란
  - B-Tree 인덱스에서 리프 페이지가 꽉 찼을 때 발생하는 구조적 변경 작업
  - 새로운 키를 삽입할 공간이 없으면 DBMS는 새로운 페이지를 할당하고, 기존 레코드의 일부를 옮겨 담아 두 페이지로 나눔
  - 이 과정에서 레코드 이동, 부모 노드 갱신, 연쇄 분할이 발생하고, 디스크 I/O와 락 경합까지 늘어나기 때문에 쓰기 성능이 크게 저하
  - 랜덤한 키(UUID, 무작위 PK)를 쓰면 분할이 자주 일어나 성능에 악영향을 줄 수 있음

---

### Unique Index
- 인덱스 키 값의 중복을 허용하지 않음
- PK와 달리 NULL 허용
- 유니크 인덱스 vs 세컨더리 인덱스
  - 읽기(Read)
    - 유니크 인덱스는 조건 만족 레코드가 최대 1개 -> **옵티마이저가 탐색 범위를 좁게** 잡음
    - 세컨더리 인덱스는 조건에 따라 여러 개 레코드 반환 가능
  - 쓰기(Write)
    - 유니크 인덱스는 Insert/Update 시마다 중복 여부 체크 필요 -> 부하 발생
    - 세컨더리 인덱스는 단순히 값 삽입/갱신만 수행
- 주의 사항
  - 유니크 인덱스 남발하면 Insert/Update 성능 크게 떨어짐
  - NULL 값 처리 주의 (NULL은 중복으로 판단하지 않음)
  - 비즈니스 로직에서 자주 조회되는 **고유 식별자**(이메일, 주민번호)는 유니크 인덱스 적합

---

### Foriegn Key
- 외래키 제약이 설정되면 자동으로 연관 테이블 칼럼에 인덱스 생성
- 특징
  - 테이블 변경(쓰기 잠금) 발생 시 잠금 경합(잠금 대기) 발생
  - 외래키 연관 없는 칼럼의 변경은 최대한 잠금 경합(잠금 대기)를 발생시키지 않음
- 대기(잠금) 발생 상황
  - 자식 테이블의 변경이 대기
    - 부모 테이블에 해당 키가 있는지 확인해야 하므로, 부모 테이블의 레코드에 Shared Lock 걸림
    - 부모가 동시에 변경 중이면 자식의 Insert/Update/Delete 대기
  - 부모 테이블의 변경이 대기
    - 자식 테이블에서 해당 키를 참조 중이면, 부모 레코드 Update/Delete 시 자식 확인 필요
    - 자식 테이블에 참조하는 레코드가 존재하면 잠금 대기 발생
- 주의 사항
  - FK는 자동으로 인덱스 생성 필요 (없으면 InnoDB가 강제로 만듦)
  - FK는 무결성을 보장하지만, 쓰기 성능(Insert/Update/Delete) 저하 발생 가능
  - 대규모 트래픽 시스템에서는 FK를 DB 대신 애플리케이션 레벨에서 검증하기도 함

---

### 스터리 질문 정리

#### 왜 PK는 되도록 짧고 불변한 값을 쓰라고 하는 걸까요?
- PK는 InnoDB에서 클러스터링 인덱스로 사용되기 때문에, 세컨더리 인덱스에도 항상 PK가 함께 저장됩니다. 따라서 **PK가 길면 모든 인덱스 크기가 커지고 디스크 I/O와 캐시 효율이 떨어집니다**. 또, PK가 자주 바뀌면 레코드 자체를 이동시켜야 하므로 성능이 크게 저하됩니다. 그래서 짧고 불변한 값을 PK로 설정하는 것이 효율적입니다.

#### 페이지 분할(Page Split)이 왜 성능 저하를 일으키나요?
- B-Tree 인덱스는 정렬된 상태를 유지해야 하는데, 중간 키 값이 삽입되면 기존 페이지를 두 개로 쪼개는 Page Split이 발생합니다. 이 과정에서 **디스크 쓰기와 페이지 이동**이 일어나고, **트랜잭션 동시 처리 시 락 경합**까지 생겨 성능이 저하됩니다. 특히 랜덤한 PK나 UUID 같은 값을 PK로 사용할 때 이런 현상이 자주 발생합니다.

#### 선택도가 낮은(중복도가 높은) 컬럼에 인덱스를 걸면 왜 성능이 떨어질까요?
- 인덱스의 장점은 검색 범위를 빠르게 줄이는 데 있습니다. 그런데 성별처럼 값의 종류가 적은 컬럼에 인덱스를 걸면, 결국 **레코드 대부분을 다시 읽어야 하므로 테이블 풀스캔과 비슷한 성능**이 나옵니다. 게다가 인덱스를 관리하는 추가 비용까지 생겨서 오히려 성능이 떨어질 수 있습니다.

#### `WHERE age+1 = 30, LIKE '%abc', != `조건이 인덱스를 타지 못하는 이유를 내부 동작 관점에서 설명해보세요.
- B-Tree 인덱스는 정렬된 값을 기반으로 탐색합니다. 그런데 age+1=30은 계산이 끝난 후에 비교할 수 있어서 인덱스 정렬 순서를 활용할 수 없습니다. LIKE '%abc'도 앞부분이 고정되지 않아 시작 위치를 찾을 수 없습니다. != 조건도 전체 범위를 다 뒤져야 하기 때문에 인덱스를 활용할 수 없습니다.
- B-Tree 인덱스는 정렬된 키의 시작 경계(start)와 끝 경계(end)를 빠르게 찾는 구조
- age+1 = 30: 옵티마이저가 인덱스 키 영역에서 바로 경계를 계산할 수 없고 각 행을 읽어와서 계산+비교해야 하므로 인덱스 활용 못함
- LIKE '%abc': B-Tree는 왼쪽부터 정렬이므로 시작 지점이 없으면 조회를 못함
- != : 같지 않음 조건은 대부분의 행이 매치될 확률이 높기 때문에, 인덱스를 타도 리프를 광범위하게 훑고 테이블 접근이 많이 발생

#### 전체 테이블 데이터의 20~25% 이상의 데이터를 가져와야 하는 경우 왜 인덱스를 이용하는 것이 비효율적인가요?
- 인덱스를 통해 데이터를 가져올 때는 인덱스 페이지 -> 데이터 페이지로 랜덤 I/O가 발생합니다. 소량일 때는 효율적이지만, 전체의 20~25% 이상을 가져올 때는 **랜덤 I/O 비용이 풀스캔보다 커집니다**. 이 경우는 차라리 테이블 전체를 순차적으로 읽는 것이 더 빠릅니다.

#### 인덱스 풀 스캔이 발생하는 경우는? + 절대 사용하지 않는 경우는?
- 풀 스캔 사용 경우
  - 정렬/최신순 조회(인덱스 순서 = 원하는 정렬), 커버링 인덱스
- 사용 안하는 경우
  - 선택도 낮은 필터, 커버링 인덱스 아니고 대량 반환, 정렬키 불일치

#### 인덱스 키 추가, 삭제, 변경 과정 설명
- 추가: B-Tree를 탐색해 적절한 위치에 삽입, 필요 시 Page Split 발생
- 삭제: 리프 노드에 삭제 마킹만 하고 나중에 삭제
- 변경: 삭제 후 새 값 추가
- 이 과정들은 모두 정렬 유지가 필요하기 때문에 단순 테이블 연산보다 비용이 큼

#### 인덱스를 사용하는 이유
- 인덱스는 데이터 조회 속도를 매우 높입니다. 정렬된 상태를 유지하므로 탐색 시 로그 시간(O(log n)) 복잡도로 접근할 수 있습니다. 대신 쓰기 성능은 희생되므로, 읽기 위주 서비스에서 사용합니다.

#### 클러스터링 인덱스 장단점
- 장점: PK 검색과 범위 검색이 매우 빠르다는 것. 데이터 자체가 PK 순서로 정렬
- 단점: PK 크기가 크거나 변경이 많으면 성능이 크게 떨어짐. 또한 삽입 시 순서가 뒤죽박죽이면 Page Split이 자주 발생.

#### 풀 테이블 스캔이 인덱스를 사용하는 것보다 효율적인 경우가 있나요?
- 선택도가 낮거나, 20~25% 이상의 데이터를 가져와야 하는 경우입니다. 이 경우 **순차 I/O가 랜덤 I/O보다 훨씬 빠르기 때문에** 테이블 풀스캔이 효율적입니다.

#### 키의 크기가 검색 성능에 어떻게 영향을 주는지 설명하세요
- 인덱스 키 크기가 커지면 하나의 페이지에 담을 수 있는 키 개수가 줄어들어 트리 깊이가 커집니다. 그만큼 디스크 접근 횟수가 늘어나 성능이 떨어집니다. 또한 캐시에 올릴 수 있는 레코드 수가 줄어들어 메모리 효율도 나빠집니다.

#### 불연속 컬럼과 연속(범위형) 컬럼으로 복합인덱스를 만든다고 할 때, 어떤 식으로 구성하는게 좋을까?
- 일반적으로 선택도가 높은 불연속 컬럼을 먼저 두고, 범위 조건이 자주 사용되는 컬럼을 뒤에 둡니다. 그래야 검색 범위를 최대한 좁힌 후에 범위 탐색을 수행할 수 있습니다.

#### InnoDB에서 세컨더리 인덱스에 실제 레코드 주소가 아닌 PK를 저장하는 이유가 무엇일까요? + 커버링 인덱스 쓰는 이유
- 세컨더리 인덱스가 행의 물리적 주소를 들고 있으면, 레코드가 이동할 때마다 모든 세컨더리 인덱스를 갱신해야 함
- 세컨더리 인덱스 리프에 쿼리에 필요한 모든 컬럼이 들어 있다면, 테이블(클러스터링 인덱스)까지 가지 않고 인덱스만 읽어도 됨 -> 커버링 인덱스(Index Only Scan) -> 랜덤 I/O를 줄이고 조회 성능을 크게 개선

---

## 3. 참고/추가 자료 (References)
- RealMySQL 8.0

---

## 4. 내일/다음에 볼 것 (Next Steps)
- 정규화 비정규화

